// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Client is the Schema for the Clients API.
 *
 * @schema Client
 */
export class Client extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Client"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'openidclient.keycloak.crossplane.io/v1alpha1',
    kind: 'Client',
  }

  /**
   * Renders a Kubernetes manifest for "Client".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClientProps): any {
    return {
      ...Client.GVK,
      ...toJson_ClientProps(props),
    };
  }

  /**
   * Defines a "Client" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClientProps) {
    super(scope, id, {
      ...Client.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Client.GVK,
      ...toJson_ClientProps(resolved),
    };
  }
}

/**
 * Client is the Schema for the Clients API.
 *
 * @schema Client
 */
export interface ClientProps {
  /**
   * @schema Client#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClientSpec defines the desired state of Client
   *
   * @schema Client#spec
   */
  readonly spec: ClientSpec;

}

/**
 * Converts an object of type 'ClientProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientProps(obj: ClientProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClientSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientSpec defines the desired state of Client
 *
 * @schema ClientSpec
 */
export interface ClientSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClientSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClientSpecDeletionPolicy;

  /**
   * @schema ClientSpec#forProvider
   */
  readonly forProvider: ClientSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ClientSpec#initProvider
   */
  readonly initProvider?: ClientSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClientSpec#managementPolicies
   */
  readonly managementPolicies?: ClientSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ClientSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClientSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ClientSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClientSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema ClientSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClientSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClientSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpec(obj: ClientSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClientSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClientSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClientSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClientSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClientSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClientSpecDeletionPolicy
 */
export enum ClientSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClientSpecForProvider
 */
export interface ClientSpecForProvider {
  /**
   * The amount of time in seconds before an access token expires. This will override the default for the realm.
   *
   * @schema ClientSpecForProvider#accessTokenLifespan
   */
  readonly accessTokenLifespan?: string;

  /**
   * Specifies the type of client, which can be one of the following:
   *
   * @schema ClientSpecForProvider#accessType
   */
  readonly accessType?: string;

  /**
   * URL to the admin interface of the client.
   *
   * @schema ClientSpecForProvider#adminUrl
   */
  readonly adminUrl?: string;

  /**
   * Override realm authentication flow bindings
   *
   * @schema ClientSpecForProvider#authenticationFlowBindingOverrides
   */
  readonly authenticationFlowBindingOverrides?: ClientSpecForProviderAuthenticationFlowBindingOverrides[];

  /**
   * When this block is present, fine-grained authorization will be enabled for this client. The client's access_type must be CONFIDENTIAL, and service_accounts_enabled must be true. This block has the following arguments:
   *
   * @schema ClientSpecForProvider#authorization
   */
  readonly authorization?: ClientSpecForProviderAuthorization[];

  /**
   * Specifying whether a "revoke_offline_access" event is included in the Logout Token when the Backchannel Logout URL is used. Keycloak will revoke offline sessions when receiving a Logout Token with this event.
   *
   * @schema ClientSpecForProvider#backchannelLogoutRevokeOfflineSessions
   */
  readonly backchannelLogoutRevokeOfflineSessions?: boolean;

  /**
   * When true, a sid (session ID) claim will be included in the logout token when the backchannel logout URL is used. Defaults to true.
   *
   * @default true.
   * @schema ClientSpecForProvider#backchannelLogoutSessionRequired
   */
  readonly backchannelLogoutSessionRequired?: boolean;

  /**
   * The URL that will cause the client to log itself out when a logout request is sent to this realm. If omitted, no logout request will be sent to the client is this case.
   *
   * @schema ClientSpecForProvider#backchannelLogoutUrl
   */
  readonly backchannelLogoutUrl?: string;

  /**
   * Default URL to use when the auth server needs to redirect or link back to the client.
   *
   * @schema ClientSpecForProvider#baseUrl
   */
  readonly baseUrl?: string;

  /**
   * Defaults to client-secret. The authenticator type for clients with an access_type of CONFIDENTIAL or BEARER-ONLY. A default Keycloak installation will have the following available types:
   *
   * @default client-secret. The authenticator type for clients with an access_type of CONFIDENTIAL or BEARER-ONLY. A default Keycloak installation will have the following available types:
   * @schema ClientSpecForProvider#clientAuthenticatorType
   */
  readonly clientAuthenticatorType?: string;

  /**
   * The Client ID for this client, referenced in the URI during authentication and in issued tokens.
   *
   * @schema ClientSpecForProvider#clientId
   */
  readonly clientId?: string;

  /**
   * Reference to a Client in openidclient to populate clientId.
   *
   * @schema ClientSpecForProvider#clientIdRef
   */
  readonly clientIdRef?: ClientSpecForProviderClientIdRef;

  /**
   * Selector for a Client in openidclient to populate clientId.
   *
   * @schema ClientSpecForProvider#clientIdSelector
   */
  readonly clientIdSelector?: ClientSpecForProviderClientIdSelector;

  /**
   * Time a client session is allowed to be idle before it expires. Tokens are invalidated when a client session is expired. If not set it uses the standard SSO Session Idle value.
   *
   * @schema ClientSpecForProvider#clientOfflineSessionIdleTimeout
   */
  readonly clientOfflineSessionIdleTimeout?: string;

  /**
   * Max time before a client session is expired. Tokens are invalidated when a client session is expired. If not set, it uses the standard SSO Session Max value.
   *
   * @schema ClientSpecForProvider#clientOfflineSessionMaxLifespan
   */
  readonly clientOfflineSessionMaxLifespan?: string;

  /**
   * The secret for clients with an access_type of CONFIDENTIAL or BEARER-ONLY. This value is sensitive and should be treated with the same care as a password. If omitted, this will be generated by Keycloak.
   *
   * @schema ClientSpecForProvider#clientSecretSecretRef
   */
  readonly clientSecretSecretRef?: ClientSpecForProviderClientSecretSecretRef;

  /**
   * Time a client offline session is allowed to be idle before it expires. Offline tokens are invalidated when a client offline session is expired. If not set it uses the Offline Session Idle value.
   *
   * @schema ClientSpecForProvider#clientSessionIdleTimeout
   */
  readonly clientSessionIdleTimeout?: string;

  /**
   * Max time before a client offline session is expired. Offline tokens are invalidated when a client offline session is expired. If not set, it uses the Offline Session Max value.
   *
   * @schema ClientSpecForProvider#clientSessionMaxLifespan
   */
  readonly clientSessionMaxLifespan?: string;

  /**
   * When true, users have to consent to client access. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecForProvider#consentRequired
   */
  readonly consentRequired?: boolean;

  /**
   * The text to display on the consent screen about permissions specific to this client. This is applicable only when display_on_consent_screen is true.
   *
   * @schema ClientSpecForProvider#consentScreenText
   */
  readonly consentScreenText?: string;

  /**
   * The description of this client in the GUI.
   *
   * @schema ClientSpecForProvider#description
   */
  readonly description?: string;

  /**
   * When true, the OAuth2 Resource Owner Password Grant will be enabled for this client. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecForProvider#directAccessGrantsEnabled
   */
  readonly directAccessGrantsEnabled?: boolean;

  /**
   * When true, the consent screen will display information about the client itself. Defaults to false. This is applicable only when consent_required is true.
   *
   * @default false. This is applicable only when consent_required is true.
   * @schema ClientSpecForProvider#displayOnConsentScreen
   */
  readonly displayOnConsentScreen?: boolean;

  /**
   * When false, this client will not be able to initiate a login or obtain access tokens. Defaults to true.
   *
   * @default true.
   * @schema ClientSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * When true, the parameter session_state will not be included in OpenID Connect Authentication Response.
   *
   * @schema ClientSpecForProvider#excludeSessionStateFromAuthResponse
   */
  readonly excludeSessionStateFromAuthResponse?: boolean;

  /**
   * A map of key/value pairs to add extra configuration attributes to this client. Use this attribute at your own risk, as it may conflict with top-level configuration attributes in future provider updates. For example, the extra_config map can be used to set Authentication Context Class Reference (ACR) to Level of Authentication (LoA) mapping
   *
   * @schema ClientSpecForProvider#extraConfig
   */
  readonly extraConfig?: { [key: string]: string };

  /**
   * When true, frontchannel logout will be enabled for this client. Specify the url with frontchannel_logout_url. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecForProvider#frontchannelLogoutEnabled
   */
  readonly frontchannelLogoutEnabled?: boolean;

  /**
   * The frontchannel logout url. This is applicable only when frontchannel_logout_enabled is true.
   *
   * @schema ClientSpecForProvider#frontchannelLogoutUrl
   */
  readonly frontchannelLogoutUrl?: string;

  /**
   * Allow to include all roles mappings in the access token.
   *
   * @schema ClientSpecForProvider#fullScopeAllowed
   */
  readonly fullScopeAllowed?: boolean;

  /**
   * When true, the OAuth2 Implicit Grant will be enabled for this client. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecForProvider#implicitFlowEnabled
   */
  readonly implicitFlowEnabled?: boolean;

  /**
   * When true, the client with the specified client_id is assumed to already exist, and it will be imported into state instead of being created. This attribute is useful when dealing with clients that Keycloak creates automatically during realm creation, such as account and admin-cli. Note, that the client will not be removed during destruction if import is true.
   *
   * @schema ClientSpecForProvider#import
   */
  readonly import?: boolean;

  /**
   * The client login theme. This will override the default theme for the realm.
   *
   * @schema ClientSpecForProvider#loginTheme
   */
  readonly loginTheme?: string;

  /**
   * The display name of this client in the GUI.
   *
   * @schema ClientSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Enables support for OAuth 2.0 Device Authorization Grant, which means that client is an application on device that has limited input capabilities or lack a suitable browser.
   *
   * @schema ClientSpecForProvider#oauth2DeviceAuthorizationGrantEnabled
   */
  readonly oauth2DeviceAuthorizationGrantEnabled?: boolean;

  /**
   * The maximum amount of time a client has to finish the device code flow before it expires.
   *
   * @schema ClientSpecForProvider#oauth2DeviceCodeLifespan
   */
  readonly oauth2DeviceCodeLifespan?: string;

  /**
   * The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.
   *
   * @schema ClientSpecForProvider#oauth2DevicePollingInterval
   */
  readonly oauth2DevicePollingInterval?: string;

  /**
   * The challenge method to use for Proof Key for Code Exchange. Can be either plain or S256 or set to empty value “.
   *
   * @schema ClientSpecForProvider#pkceCodeChallengeMethod
   */
  readonly pkceCodeChallengeMethod?: string;

  /**
   * The realm this client is attached to.
   *
   * @schema ClientSpecForProvider#realmId
   */
  readonly realmId?: string;

  /**
   * Reference to a Realm in realm to populate realmId.
   *
   * @schema ClientSpecForProvider#realmIdRef
   */
  readonly realmIdRef?: ClientSpecForProviderRealmIdRef;

  /**
   * Selector for a Realm in realm to populate realmId.
   *
   * @schema ClientSpecForProvider#realmIdSelector
   */
  readonly realmIdSelector?: ClientSpecForProviderRealmIdSelector;

  /**
   * When specified, this URL is prepended to any relative URLs found within valid_redirect_uris, web_origins, and admin_url. NOTE: Due to limitations in the Keycloak API, when the root_url attribute is used, the valid_redirect_uris, web_origins, and admin_url attributes will be required.
   *
   * @schema ClientSpecForProvider#rootUrl
   */
  readonly rootUrl?: string;

  /**
   * When true, the OAuth2 Client Credentials grant will be enabled for this client. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecForProvider#serviceAccountsEnabled
   */
  readonly serviceAccountsEnabled?: boolean;

  /**
   * When true, the OAuth2 Authorization Code Grant will be enabled for this client. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecForProvider#standardFlowEnabled
   */
  readonly standardFlowEnabled?: boolean;

  /**
   * If this is true, a refresh_token will be created and added to the token response. If this is false then no refresh_token will be generated.  Defaults to true.
   *
   * @default true.
   * @schema ClientSpecForProvider#useRefreshTokens
   */
  readonly useRefreshTokens?: boolean;

  /**
   * If this is true, a refresh_token will be created and added to the token response if the client_credentials grant is used and a user session will be created. If this is false then no refresh_token will be generated and the associated user session will be removed, in accordance with OAuth 2.0 RFC6749 Section 4.4.3. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecForProvider#useRefreshTokensClientCredentials
   */
  readonly useRefreshTokensClientCredentials?: boolean;

  /**
   * A list of valid URIs a browser is permitted to redirect to after a successful logout.
   *
   * @schema ClientSpecForProvider#validPostLogoutRedirectUris
   */
  readonly validPostLogoutRedirectUris?: string[];

  /**
   * A list of valid URIs a browser is permitted to redirect to after a successful login or logout. Simple
   * wildcards in the form of an asterisk can be used here. This attribute must be set if either standard_flow_enabled or implicit_flow_enabled
   * is set to true.
   *
   * @schema ClientSpecForProvider#validRedirectUris
   */
  readonly validRedirectUris?: string[];

  /**
   * A list of allowed CORS origins. To permit all valid redirect URIs, add +. Note that this will not include the * wildcard. To permit all origins, explicitly add *.
   *
   * @schema ClientSpecForProvider#webOrigins
   */
  readonly webOrigins?: string[];

}

/**
 * Converts an object of type 'ClientSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProvider(obj: ClientSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenLifespan': obj.accessTokenLifespan,
    'accessType': obj.accessType,
    'adminUrl': obj.adminUrl,
    'authenticationFlowBindingOverrides': obj.authenticationFlowBindingOverrides?.map(y => toJson_ClientSpecForProviderAuthenticationFlowBindingOverrides(y)),
    'authorization': obj.authorization?.map(y => toJson_ClientSpecForProviderAuthorization(y)),
    'backchannelLogoutRevokeOfflineSessions': obj.backchannelLogoutRevokeOfflineSessions,
    'backchannelLogoutSessionRequired': obj.backchannelLogoutSessionRequired,
    'backchannelLogoutUrl': obj.backchannelLogoutUrl,
    'baseUrl': obj.baseUrl,
    'clientAuthenticatorType': obj.clientAuthenticatorType,
    'clientId': obj.clientId,
    'clientIdRef': toJson_ClientSpecForProviderClientIdRef(obj.clientIdRef),
    'clientIdSelector': toJson_ClientSpecForProviderClientIdSelector(obj.clientIdSelector),
    'clientOfflineSessionIdleTimeout': obj.clientOfflineSessionIdleTimeout,
    'clientOfflineSessionMaxLifespan': obj.clientOfflineSessionMaxLifespan,
    'clientSecretSecretRef': toJson_ClientSpecForProviderClientSecretSecretRef(obj.clientSecretSecretRef),
    'clientSessionIdleTimeout': obj.clientSessionIdleTimeout,
    'clientSessionMaxLifespan': obj.clientSessionMaxLifespan,
    'consentRequired': obj.consentRequired,
    'consentScreenText': obj.consentScreenText,
    'description': obj.description,
    'directAccessGrantsEnabled': obj.directAccessGrantsEnabled,
    'displayOnConsentScreen': obj.displayOnConsentScreen,
    'enabled': obj.enabled,
    'excludeSessionStateFromAuthResponse': obj.excludeSessionStateFromAuthResponse,
    'extraConfig': ((obj.extraConfig) === undefined) ? undefined : (Object.entries(obj.extraConfig).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'frontchannelLogoutEnabled': obj.frontchannelLogoutEnabled,
    'frontchannelLogoutUrl': obj.frontchannelLogoutUrl,
    'fullScopeAllowed': obj.fullScopeAllowed,
    'implicitFlowEnabled': obj.implicitFlowEnabled,
    'import': obj.import,
    'loginTheme': obj.loginTheme,
    'name': obj.name,
    'oauth2DeviceAuthorizationGrantEnabled': obj.oauth2DeviceAuthorizationGrantEnabled,
    'oauth2DeviceCodeLifespan': obj.oauth2DeviceCodeLifespan,
    'oauth2DevicePollingInterval': obj.oauth2DevicePollingInterval,
    'pkceCodeChallengeMethod': obj.pkceCodeChallengeMethod,
    'realmId': obj.realmId,
    'realmIdRef': toJson_ClientSpecForProviderRealmIdRef(obj.realmIdRef),
    'realmIdSelector': toJson_ClientSpecForProviderRealmIdSelector(obj.realmIdSelector),
    'rootUrl': obj.rootUrl,
    'serviceAccountsEnabled': obj.serviceAccountsEnabled,
    'standardFlowEnabled': obj.standardFlowEnabled,
    'useRefreshTokens': obj.useRefreshTokens,
    'useRefreshTokensClientCredentials': obj.useRefreshTokensClientCredentials,
    'validPostLogoutRedirectUris': obj.validPostLogoutRedirectUris?.map(y => y),
    'validRedirectUris': obj.validRedirectUris?.map(y => y),
    'webOrigins': obj.webOrigins?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ClientSpecInitProvider
 */
export interface ClientSpecInitProvider {
  /**
   * The amount of time in seconds before an access token expires. This will override the default for the realm.
   *
   * @schema ClientSpecInitProvider#accessTokenLifespan
   */
  readonly accessTokenLifespan?: string;

  /**
   * Specifies the type of client, which can be one of the following:
   *
   * @schema ClientSpecInitProvider#accessType
   */
  readonly accessType?: string;

  /**
   * URL to the admin interface of the client.
   *
   * @schema ClientSpecInitProvider#adminUrl
   */
  readonly adminUrl?: string;

  /**
   * Override realm authentication flow bindings
   *
   * @schema ClientSpecInitProvider#authenticationFlowBindingOverrides
   */
  readonly authenticationFlowBindingOverrides?: ClientSpecInitProviderAuthenticationFlowBindingOverrides[];

  /**
   * When this block is present, fine-grained authorization will be enabled for this client. The client's access_type must be CONFIDENTIAL, and service_accounts_enabled must be true. This block has the following arguments:
   *
   * @schema ClientSpecInitProvider#authorization
   */
  readonly authorization?: ClientSpecInitProviderAuthorization[];

  /**
   * Specifying whether a "revoke_offline_access" event is included in the Logout Token when the Backchannel Logout URL is used. Keycloak will revoke offline sessions when receiving a Logout Token with this event.
   *
   * @schema ClientSpecInitProvider#backchannelLogoutRevokeOfflineSessions
   */
  readonly backchannelLogoutRevokeOfflineSessions?: boolean;

  /**
   * When true, a sid (session ID) claim will be included in the logout token when the backchannel logout URL is used. Defaults to true.
   *
   * @default true.
   * @schema ClientSpecInitProvider#backchannelLogoutSessionRequired
   */
  readonly backchannelLogoutSessionRequired?: boolean;

  /**
   * The URL that will cause the client to log itself out when a logout request is sent to this realm. If omitted, no logout request will be sent to the client is this case.
   *
   * @schema ClientSpecInitProvider#backchannelLogoutUrl
   */
  readonly backchannelLogoutUrl?: string;

  /**
   * Default URL to use when the auth server needs to redirect or link back to the client.
   *
   * @schema ClientSpecInitProvider#baseUrl
   */
  readonly baseUrl?: string;

  /**
   * Defaults to client-secret. The authenticator type for clients with an access_type of CONFIDENTIAL or BEARER-ONLY. A default Keycloak installation will have the following available types:
   *
   * @default client-secret. The authenticator type for clients with an access_type of CONFIDENTIAL or BEARER-ONLY. A default Keycloak installation will have the following available types:
   * @schema ClientSpecInitProvider#clientAuthenticatorType
   */
  readonly clientAuthenticatorType?: string;

  /**
   * The Client ID for this client, referenced in the URI during authentication and in issued tokens.
   *
   * @schema ClientSpecInitProvider#clientId
   */
  readonly clientId?: string;

  /**
   * Reference to a Client in openidclient to populate clientId.
   *
   * @schema ClientSpecInitProvider#clientIdRef
   */
  readonly clientIdRef?: ClientSpecInitProviderClientIdRef;

  /**
   * Selector for a Client in openidclient to populate clientId.
   *
   * @schema ClientSpecInitProvider#clientIdSelector
   */
  readonly clientIdSelector?: ClientSpecInitProviderClientIdSelector;

  /**
   * Time a client session is allowed to be idle before it expires. Tokens are invalidated when a client session is expired. If not set it uses the standard SSO Session Idle value.
   *
   * @schema ClientSpecInitProvider#clientOfflineSessionIdleTimeout
   */
  readonly clientOfflineSessionIdleTimeout?: string;

  /**
   * Max time before a client session is expired. Tokens are invalidated when a client session is expired. If not set, it uses the standard SSO Session Max value.
   *
   * @schema ClientSpecInitProvider#clientOfflineSessionMaxLifespan
   */
  readonly clientOfflineSessionMaxLifespan?: string;

  /**
   * The secret for clients with an access_type of CONFIDENTIAL or BEARER-ONLY. This value is sensitive and should be treated with the same care as a password. If omitted, this will be generated by Keycloak.
   *
   * @schema ClientSpecInitProvider#clientSecretSecretRef
   */
  readonly clientSecretSecretRef?: ClientSpecInitProviderClientSecretSecretRef;

  /**
   * Time a client offline session is allowed to be idle before it expires. Offline tokens are invalidated when a client offline session is expired. If not set it uses the Offline Session Idle value.
   *
   * @schema ClientSpecInitProvider#clientSessionIdleTimeout
   */
  readonly clientSessionIdleTimeout?: string;

  /**
   * Max time before a client offline session is expired. Offline tokens are invalidated when a client offline session is expired. If not set, it uses the Offline Session Max value.
   *
   * @schema ClientSpecInitProvider#clientSessionMaxLifespan
   */
  readonly clientSessionMaxLifespan?: string;

  /**
   * When true, users have to consent to client access. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecInitProvider#consentRequired
   */
  readonly consentRequired?: boolean;

  /**
   * The text to display on the consent screen about permissions specific to this client. This is applicable only when display_on_consent_screen is true.
   *
   * @schema ClientSpecInitProvider#consentScreenText
   */
  readonly consentScreenText?: string;

  /**
   * The description of this client in the GUI.
   *
   * @schema ClientSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * When true, the OAuth2 Resource Owner Password Grant will be enabled for this client. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecInitProvider#directAccessGrantsEnabled
   */
  readonly directAccessGrantsEnabled?: boolean;

  /**
   * When true, the consent screen will display information about the client itself. Defaults to false. This is applicable only when consent_required is true.
   *
   * @default false. This is applicable only when consent_required is true.
   * @schema ClientSpecInitProvider#displayOnConsentScreen
   */
  readonly displayOnConsentScreen?: boolean;

  /**
   * When false, this client will not be able to initiate a login or obtain access tokens. Defaults to true.
   *
   * @default true.
   * @schema ClientSpecInitProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * When true, the parameter session_state will not be included in OpenID Connect Authentication Response.
   *
   * @schema ClientSpecInitProvider#excludeSessionStateFromAuthResponse
   */
  readonly excludeSessionStateFromAuthResponse?: boolean;

  /**
   * A map of key/value pairs to add extra configuration attributes to this client. Use this attribute at your own risk, as it may conflict with top-level configuration attributes in future provider updates. For example, the extra_config map can be used to set Authentication Context Class Reference (ACR) to Level of Authentication (LoA) mapping
   *
   * @schema ClientSpecInitProvider#extraConfig
   */
  readonly extraConfig?: { [key: string]: string };

  /**
   * When true, frontchannel logout will be enabled for this client. Specify the url with frontchannel_logout_url. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecInitProvider#frontchannelLogoutEnabled
   */
  readonly frontchannelLogoutEnabled?: boolean;

  /**
   * The frontchannel logout url. This is applicable only when frontchannel_logout_enabled is true.
   *
   * @schema ClientSpecInitProvider#frontchannelLogoutUrl
   */
  readonly frontchannelLogoutUrl?: string;

  /**
   * Allow to include all roles mappings in the access token.
   *
   * @schema ClientSpecInitProvider#fullScopeAllowed
   */
  readonly fullScopeAllowed?: boolean;

  /**
   * When true, the OAuth2 Implicit Grant will be enabled for this client. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecInitProvider#implicitFlowEnabled
   */
  readonly implicitFlowEnabled?: boolean;

  /**
   * When true, the client with the specified client_id is assumed to already exist, and it will be imported into state instead of being created. This attribute is useful when dealing with clients that Keycloak creates automatically during realm creation, such as account and admin-cli. Note, that the client will not be removed during destruction if import is true.
   *
   * @schema ClientSpecInitProvider#import
   */
  readonly import?: boolean;

  /**
   * The client login theme. This will override the default theme for the realm.
   *
   * @schema ClientSpecInitProvider#loginTheme
   */
  readonly loginTheme?: string;

  /**
   * The display name of this client in the GUI.
   *
   * @schema ClientSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Enables support for OAuth 2.0 Device Authorization Grant, which means that client is an application on device that has limited input capabilities or lack a suitable browser.
   *
   * @schema ClientSpecInitProvider#oauth2DeviceAuthorizationGrantEnabled
   */
  readonly oauth2DeviceAuthorizationGrantEnabled?: boolean;

  /**
   * The maximum amount of time a client has to finish the device code flow before it expires.
   *
   * @schema ClientSpecInitProvider#oauth2DeviceCodeLifespan
   */
  readonly oauth2DeviceCodeLifespan?: string;

  /**
   * The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.
   *
   * @schema ClientSpecInitProvider#oauth2DevicePollingInterval
   */
  readonly oauth2DevicePollingInterval?: string;

  /**
   * The challenge method to use for Proof Key for Code Exchange. Can be either plain or S256 or set to empty value “.
   *
   * @schema ClientSpecInitProvider#pkceCodeChallengeMethod
   */
  readonly pkceCodeChallengeMethod?: string;

  /**
   * The realm this client is attached to.
   *
   * @schema ClientSpecInitProvider#realmId
   */
  readonly realmId?: string;

  /**
   * Reference to a Realm in realm to populate realmId.
   *
   * @schema ClientSpecInitProvider#realmIdRef
   */
  readonly realmIdRef?: ClientSpecInitProviderRealmIdRef;

  /**
   * Selector for a Realm in realm to populate realmId.
   *
   * @schema ClientSpecInitProvider#realmIdSelector
   */
  readonly realmIdSelector?: ClientSpecInitProviderRealmIdSelector;

  /**
   * When specified, this URL is prepended to any relative URLs found within valid_redirect_uris, web_origins, and admin_url. NOTE: Due to limitations in the Keycloak API, when the root_url attribute is used, the valid_redirect_uris, web_origins, and admin_url attributes will be required.
   *
   * @schema ClientSpecInitProvider#rootUrl
   */
  readonly rootUrl?: string;

  /**
   * When true, the OAuth2 Client Credentials grant will be enabled for this client. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecInitProvider#serviceAccountsEnabled
   */
  readonly serviceAccountsEnabled?: boolean;

  /**
   * When true, the OAuth2 Authorization Code Grant will be enabled for this client. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecInitProvider#standardFlowEnabled
   */
  readonly standardFlowEnabled?: boolean;

  /**
   * If this is true, a refresh_token will be created and added to the token response. If this is false then no refresh_token will be generated.  Defaults to true.
   *
   * @default true.
   * @schema ClientSpecInitProvider#useRefreshTokens
   */
  readonly useRefreshTokens?: boolean;

  /**
   * If this is true, a refresh_token will be created and added to the token response if the client_credentials grant is used and a user session will be created. If this is false then no refresh_token will be generated and the associated user session will be removed, in accordance with OAuth 2.0 RFC6749 Section 4.4.3. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecInitProvider#useRefreshTokensClientCredentials
   */
  readonly useRefreshTokensClientCredentials?: boolean;

  /**
   * A list of valid URIs a browser is permitted to redirect to after a successful logout.
   *
   * @schema ClientSpecInitProvider#validPostLogoutRedirectUris
   */
  readonly validPostLogoutRedirectUris?: string[];

  /**
   * A list of valid URIs a browser is permitted to redirect to after a successful login or logout. Simple
   * wildcards in the form of an asterisk can be used here. This attribute must be set if either standard_flow_enabled or implicit_flow_enabled
   * is set to true.
   *
   * @schema ClientSpecInitProvider#validRedirectUris
   */
  readonly validRedirectUris?: string[];

  /**
   * A list of allowed CORS origins. To permit all valid redirect URIs, add +. Note that this will not include the * wildcard. To permit all origins, explicitly add *.
   *
   * @schema ClientSpecInitProvider#webOrigins
   */
  readonly webOrigins?: string[];

}

/**
 * Converts an object of type 'ClientSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProvider(obj: ClientSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenLifespan': obj.accessTokenLifespan,
    'accessType': obj.accessType,
    'adminUrl': obj.adminUrl,
    'authenticationFlowBindingOverrides': obj.authenticationFlowBindingOverrides?.map(y => toJson_ClientSpecInitProviderAuthenticationFlowBindingOverrides(y)),
    'authorization': obj.authorization?.map(y => toJson_ClientSpecInitProviderAuthorization(y)),
    'backchannelLogoutRevokeOfflineSessions': obj.backchannelLogoutRevokeOfflineSessions,
    'backchannelLogoutSessionRequired': obj.backchannelLogoutSessionRequired,
    'backchannelLogoutUrl': obj.backchannelLogoutUrl,
    'baseUrl': obj.baseUrl,
    'clientAuthenticatorType': obj.clientAuthenticatorType,
    'clientId': obj.clientId,
    'clientIdRef': toJson_ClientSpecInitProviderClientIdRef(obj.clientIdRef),
    'clientIdSelector': toJson_ClientSpecInitProviderClientIdSelector(obj.clientIdSelector),
    'clientOfflineSessionIdleTimeout': obj.clientOfflineSessionIdleTimeout,
    'clientOfflineSessionMaxLifespan': obj.clientOfflineSessionMaxLifespan,
    'clientSecretSecretRef': toJson_ClientSpecInitProviderClientSecretSecretRef(obj.clientSecretSecretRef),
    'clientSessionIdleTimeout': obj.clientSessionIdleTimeout,
    'clientSessionMaxLifespan': obj.clientSessionMaxLifespan,
    'consentRequired': obj.consentRequired,
    'consentScreenText': obj.consentScreenText,
    'description': obj.description,
    'directAccessGrantsEnabled': obj.directAccessGrantsEnabled,
    'displayOnConsentScreen': obj.displayOnConsentScreen,
    'enabled': obj.enabled,
    'excludeSessionStateFromAuthResponse': obj.excludeSessionStateFromAuthResponse,
    'extraConfig': ((obj.extraConfig) === undefined) ? undefined : (Object.entries(obj.extraConfig).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'frontchannelLogoutEnabled': obj.frontchannelLogoutEnabled,
    'frontchannelLogoutUrl': obj.frontchannelLogoutUrl,
    'fullScopeAllowed': obj.fullScopeAllowed,
    'implicitFlowEnabled': obj.implicitFlowEnabled,
    'import': obj.import,
    'loginTheme': obj.loginTheme,
    'name': obj.name,
    'oauth2DeviceAuthorizationGrantEnabled': obj.oauth2DeviceAuthorizationGrantEnabled,
    'oauth2DeviceCodeLifespan': obj.oauth2DeviceCodeLifespan,
    'oauth2DevicePollingInterval': obj.oauth2DevicePollingInterval,
    'pkceCodeChallengeMethod': obj.pkceCodeChallengeMethod,
    'realmId': obj.realmId,
    'realmIdRef': toJson_ClientSpecInitProviderRealmIdRef(obj.realmIdRef),
    'realmIdSelector': toJson_ClientSpecInitProviderRealmIdSelector(obj.realmIdSelector),
    'rootUrl': obj.rootUrl,
    'serviceAccountsEnabled': obj.serviceAccountsEnabled,
    'standardFlowEnabled': obj.standardFlowEnabled,
    'useRefreshTokens': obj.useRefreshTokens,
    'useRefreshTokensClientCredentials': obj.useRefreshTokensClientCredentials,
    'validPostLogoutRedirectUris': obj.validPostLogoutRedirectUris?.map(y => y),
    'validRedirectUris': obj.validRedirectUris?.map(y => y),
    'webOrigins': obj.webOrigins?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ClientSpecManagementPolicies
 */
export enum ClientSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ClientSpecProviderConfigRef
 */
export interface ClientSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientSpecProviderConfigRef#policy
   */
  readonly policy?: ClientSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClientSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecProviderConfigRef(obj: ClientSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ClientSpecPublishConnectionDetailsTo
 */
export interface ClientSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema ClientSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClientSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClientSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClientSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClientSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClientSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecPublishConnectionDetailsTo(obj: ClientSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClientSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClientSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema ClientSpecWriteConnectionSecretToRef
 */
export interface ClientSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClientSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClientSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClientSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecWriteConnectionSecretToRef(obj: ClientSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverrides
 */
export interface ClientSpecForProviderAuthenticationFlowBindingOverrides {
  /**
   * Browser flow id, (flow needs to exist)
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverrides#browserId
   */
  readonly browserId?: string;

  /**
   * Reference to a Flow in authenticationflow to populate browserId.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverrides#browserIdRef
   */
  readonly browserIdRef?: ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRef;

  /**
   * Selector for a Flow in authenticationflow to populate browserId.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverrides#browserIdSelector
   */
  readonly browserIdSelector?: ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelector;

  /**
   * Direct grant flow id (flow needs to exist)
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverrides#directGrantId
   */
  readonly directGrantId?: string;

  /**
   * Reference to a Flow in authenticationflow to populate directGrantId.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverrides#directGrantIdRef
   */
  readonly directGrantIdRef?: ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRef;

  /**
   * Selector for a Flow in authenticationflow to populate directGrantId.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverrides#directGrantIdSelector
   */
  readonly directGrantIdSelector?: ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector;

}

/**
 * Converts an object of type 'ClientSpecForProviderAuthenticationFlowBindingOverrides' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderAuthenticationFlowBindingOverrides(obj: ClientSpecForProviderAuthenticationFlowBindingOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'browserId': obj.browserId,
    'browserIdRef': toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRef(obj.browserIdRef),
    'browserIdSelector': toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelector(obj.browserIdSelector),
    'directGrantId': obj.directGrantId,
    'directGrantIdRef': toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRef(obj.directGrantIdRef),
    'directGrantIdSelector': toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector(obj.directGrantIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClientSpecForProviderAuthorization
 */
export interface ClientSpecForProviderAuthorization {
  /**
   * When true, resources can be managed remotely by the resource server. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecForProviderAuthorization#allowRemoteResourceManagement
   */
  readonly allowRemoteResourceManagement?: boolean;

  /**
   * Dictates how the policies associated with a given permission are evaluated and how a final decision is obtained. Could be one of AFFIRMATIVE, CONSENSUS, or UNANIMOUS. Applies to permissions.
   *
   * @schema ClientSpecForProviderAuthorization#decisionStrategy
   */
  readonly decisionStrategy?: string;

  /**
   * When true, defaults set by Keycloak will be respected. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecForProviderAuthorization#keepDefaults
   */
  readonly keepDefaults?: boolean;

  /**
   * Dictates how policies are enforced when evaluating authorization requests. Can be one of ENFORCING, PERMISSIVE, or DISABLED.
   *
   * @schema ClientSpecForProviderAuthorization#policyEnforcementMode
   */
  readonly policyEnforcementMode?: string;

}

/**
 * Converts an object of type 'ClientSpecForProviderAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderAuthorization(obj: ClientSpecForProviderAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowRemoteResourceManagement': obj.allowRemoteResourceManagement,
    'decisionStrategy': obj.decisionStrategy,
    'keepDefaults': obj.keepDefaults,
    'policyEnforcementMode': obj.policyEnforcementMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Client in openidclient to populate clientId.
 *
 * @schema ClientSpecForProviderClientIdRef
 */
export interface ClientSpecForProviderClientIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientSpecForProviderClientIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientSpecForProviderClientIdRef#policy
   */
  readonly policy?: ClientSpecForProviderClientIdRefPolicy;

}

/**
 * Converts an object of type 'ClientSpecForProviderClientIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderClientIdRef(obj: ClientSpecForProviderClientIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientSpecForProviderClientIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Client in openidclient to populate clientId.
 *
 * @schema ClientSpecForProviderClientIdSelector
 */
export interface ClientSpecForProviderClientIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClientSpecForProviderClientIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClientSpecForProviderClientIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClientSpecForProviderClientIdSelector#policy
   */
  readonly policy?: ClientSpecForProviderClientIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClientSpecForProviderClientIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderClientIdSelector(obj: ClientSpecForProviderClientIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClientSpecForProviderClientIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret for clients with an access_type of CONFIDENTIAL or BEARER-ONLY. This value is sensitive and should be treated with the same care as a password. If omitted, this will be generated by Keycloak.
 *
 * @schema ClientSpecForProviderClientSecretSecretRef
 */
export interface ClientSpecForProviderClientSecretSecretRef {
  /**
   * The key to select.
   *
   * @schema ClientSpecForProviderClientSecretSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ClientSpecForProviderClientSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClientSpecForProviderClientSecretSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClientSpecForProviderClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderClientSecretSecretRef(obj: ClientSpecForProviderClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Realm in realm to populate realmId.
 *
 * @schema ClientSpecForProviderRealmIdRef
 */
export interface ClientSpecForProviderRealmIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientSpecForProviderRealmIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientSpecForProviderRealmIdRef#policy
   */
  readonly policy?: ClientSpecForProviderRealmIdRefPolicy;

}

/**
 * Converts an object of type 'ClientSpecForProviderRealmIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderRealmIdRef(obj: ClientSpecForProviderRealmIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientSpecForProviderRealmIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Realm in realm to populate realmId.
 *
 * @schema ClientSpecForProviderRealmIdSelector
 */
export interface ClientSpecForProviderRealmIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClientSpecForProviderRealmIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClientSpecForProviderRealmIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClientSpecForProviderRealmIdSelector#policy
   */
  readonly policy?: ClientSpecForProviderRealmIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClientSpecForProviderRealmIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderRealmIdSelector(obj: ClientSpecForProviderRealmIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClientSpecForProviderRealmIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverrides
 */
export interface ClientSpecInitProviderAuthenticationFlowBindingOverrides {
  /**
   * Browser flow id, (flow needs to exist)
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverrides#browserId
   */
  readonly browserId?: string;

  /**
   * Reference to a Flow in authenticationflow to populate browserId.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverrides#browserIdRef
   */
  readonly browserIdRef?: ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRef;

  /**
   * Selector for a Flow in authenticationflow to populate browserId.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverrides#browserIdSelector
   */
  readonly browserIdSelector?: ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelector;

  /**
   * Direct grant flow id (flow needs to exist)
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverrides#directGrantId
   */
  readonly directGrantId?: string;

  /**
   * Reference to a Flow in authenticationflow to populate directGrantId.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverrides#directGrantIdRef
   */
  readonly directGrantIdRef?: ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRef;

  /**
   * Selector for a Flow in authenticationflow to populate directGrantId.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverrides#directGrantIdSelector
   */
  readonly directGrantIdSelector?: ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector;

}

/**
 * Converts an object of type 'ClientSpecInitProviderAuthenticationFlowBindingOverrides' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderAuthenticationFlowBindingOverrides(obj: ClientSpecInitProviderAuthenticationFlowBindingOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'browserId': obj.browserId,
    'browserIdRef': toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRef(obj.browserIdRef),
    'browserIdSelector': toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelector(obj.browserIdSelector),
    'directGrantId': obj.directGrantId,
    'directGrantIdRef': toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRef(obj.directGrantIdRef),
    'directGrantIdSelector': toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector(obj.directGrantIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClientSpecInitProviderAuthorization
 */
export interface ClientSpecInitProviderAuthorization {
  /**
   * When true, resources can be managed remotely by the resource server. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecInitProviderAuthorization#allowRemoteResourceManagement
   */
  readonly allowRemoteResourceManagement?: boolean;

  /**
   * Dictates how the policies associated with a given permission are evaluated and how a final decision is obtained. Could be one of AFFIRMATIVE, CONSENSUS, or UNANIMOUS. Applies to permissions.
   *
   * @schema ClientSpecInitProviderAuthorization#decisionStrategy
   */
  readonly decisionStrategy?: string;

  /**
   * When true, defaults set by Keycloak will be respected. Defaults to false.
   *
   * @default false.
   * @schema ClientSpecInitProviderAuthorization#keepDefaults
   */
  readonly keepDefaults?: boolean;

  /**
   * Dictates how policies are enforced when evaluating authorization requests. Can be one of ENFORCING, PERMISSIVE, or DISABLED.
   *
   * @schema ClientSpecInitProviderAuthorization#policyEnforcementMode
   */
  readonly policyEnforcementMode?: string;

}

/**
 * Converts an object of type 'ClientSpecInitProviderAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderAuthorization(obj: ClientSpecInitProviderAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowRemoteResourceManagement': obj.allowRemoteResourceManagement,
    'decisionStrategy': obj.decisionStrategy,
    'keepDefaults': obj.keepDefaults,
    'policyEnforcementMode': obj.policyEnforcementMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Client in openidclient to populate clientId.
 *
 * @schema ClientSpecInitProviderClientIdRef
 */
export interface ClientSpecInitProviderClientIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientSpecInitProviderClientIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientSpecInitProviderClientIdRef#policy
   */
  readonly policy?: ClientSpecInitProviderClientIdRefPolicy;

}

/**
 * Converts an object of type 'ClientSpecInitProviderClientIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderClientIdRef(obj: ClientSpecInitProviderClientIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientSpecInitProviderClientIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Client in openidclient to populate clientId.
 *
 * @schema ClientSpecInitProviderClientIdSelector
 */
export interface ClientSpecInitProviderClientIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClientSpecInitProviderClientIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClientSpecInitProviderClientIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClientSpecInitProviderClientIdSelector#policy
   */
  readonly policy?: ClientSpecInitProviderClientIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClientSpecInitProviderClientIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderClientIdSelector(obj: ClientSpecInitProviderClientIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClientSpecInitProviderClientIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret for clients with an access_type of CONFIDENTIAL or BEARER-ONLY. This value is sensitive and should be treated with the same care as a password. If omitted, this will be generated by Keycloak.
 *
 * @schema ClientSpecInitProviderClientSecretSecretRef
 */
export interface ClientSpecInitProviderClientSecretSecretRef {
  /**
   * The key to select.
   *
   * @schema ClientSpecInitProviderClientSecretSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ClientSpecInitProviderClientSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClientSpecInitProviderClientSecretSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClientSpecInitProviderClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderClientSecretSecretRef(obj: ClientSpecInitProviderClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Realm in realm to populate realmId.
 *
 * @schema ClientSpecInitProviderRealmIdRef
 */
export interface ClientSpecInitProviderRealmIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientSpecInitProviderRealmIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientSpecInitProviderRealmIdRef#policy
   */
  readonly policy?: ClientSpecInitProviderRealmIdRefPolicy;

}

/**
 * Converts an object of type 'ClientSpecInitProviderRealmIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderRealmIdRef(obj: ClientSpecInitProviderRealmIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientSpecInitProviderRealmIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Realm in realm to populate realmId.
 *
 * @schema ClientSpecInitProviderRealmIdSelector
 */
export interface ClientSpecInitProviderRealmIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClientSpecInitProviderRealmIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClientSpecInitProviderRealmIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClientSpecInitProviderRealmIdSelector#policy
   */
  readonly policy?: ClientSpecInitProviderRealmIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClientSpecInitProviderRealmIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderRealmIdSelector(obj: ClientSpecInitProviderRealmIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClientSpecInitProviderRealmIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClientSpecProviderConfigRefPolicy
 */
export interface ClientSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClientSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClientSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecProviderConfigRefPolicy(obj: ClientSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema ClientSpecPublishConnectionDetailsToConfigRef
 */
export interface ClientSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClientSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClientSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecPublishConnectionDetailsToConfigRef(obj: ClientSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClientSpecPublishConnectionDetailsToMetadata
 */
export interface ClientSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ClientSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ClientSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClientSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClientSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecPublishConnectionDetailsToMetadata(obj: ClientSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Flow in authenticationflow to populate browserId.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRef
 */
export interface ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRef#policy
   */
  readonly policy?: ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy;

}

/**
 * Converts an object of type 'ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRef(obj: ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Flow in authenticationflow to populate browserId.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelector
 */
export interface ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelector#policy
   */
  readonly policy?: ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelector(obj: ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Flow in authenticationflow to populate directGrantId.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRef
 */
export interface ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRef#policy
   */
  readonly policy?: ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy;

}

/**
 * Converts an object of type 'ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRef(obj: ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Flow in authenticationflow to populate directGrantId.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector
 */
export interface ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector#policy
   */
  readonly policy?: ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector(obj: ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClientSpecForProviderClientIdRefPolicy
 */
export interface ClientSpecForProviderClientIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecForProviderClientIdRefPolicy#resolution
   */
  readonly resolution?: ClientSpecForProviderClientIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecForProviderClientIdRefPolicy#resolve
   */
  readonly resolve?: ClientSpecForProviderClientIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecForProviderClientIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderClientIdRefPolicy(obj: ClientSpecForProviderClientIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClientSpecForProviderClientIdSelectorPolicy
 */
export interface ClientSpecForProviderClientIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecForProviderClientIdSelectorPolicy#resolution
   */
  readonly resolution?: ClientSpecForProviderClientIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecForProviderClientIdSelectorPolicy#resolve
   */
  readonly resolve?: ClientSpecForProviderClientIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecForProviderClientIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderClientIdSelectorPolicy(obj: ClientSpecForProviderClientIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClientSpecForProviderRealmIdRefPolicy
 */
export interface ClientSpecForProviderRealmIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecForProviderRealmIdRefPolicy#resolution
   */
  readonly resolution?: ClientSpecForProviderRealmIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecForProviderRealmIdRefPolicy#resolve
   */
  readonly resolve?: ClientSpecForProviderRealmIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecForProviderRealmIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderRealmIdRefPolicy(obj: ClientSpecForProviderRealmIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClientSpecForProviderRealmIdSelectorPolicy
 */
export interface ClientSpecForProviderRealmIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecForProviderRealmIdSelectorPolicy#resolution
   */
  readonly resolution?: ClientSpecForProviderRealmIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecForProviderRealmIdSelectorPolicy#resolve
   */
  readonly resolve?: ClientSpecForProviderRealmIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecForProviderRealmIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderRealmIdSelectorPolicy(obj: ClientSpecForProviderRealmIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Flow in authenticationflow to populate browserId.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRef
 */
export interface ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRef#policy
   */
  readonly policy?: ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy;

}

/**
 * Converts an object of type 'ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRef(obj: ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Flow in authenticationflow to populate browserId.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelector
 */
export interface ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelector#policy
   */
  readonly policy?: ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelector(obj: ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Flow in authenticationflow to populate directGrantId.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRef
 */
export interface ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRef#policy
   */
  readonly policy?: ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy;

}

/**
 * Converts an object of type 'ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRef(obj: ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Flow in authenticationflow to populate directGrantId.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector
 */
export interface ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector#policy
   */
  readonly policy?: ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector(obj: ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClientSpecInitProviderClientIdRefPolicy
 */
export interface ClientSpecInitProviderClientIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecInitProviderClientIdRefPolicy#resolution
   */
  readonly resolution?: ClientSpecInitProviderClientIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecInitProviderClientIdRefPolicy#resolve
   */
  readonly resolve?: ClientSpecInitProviderClientIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecInitProviderClientIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderClientIdRefPolicy(obj: ClientSpecInitProviderClientIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClientSpecInitProviderClientIdSelectorPolicy
 */
export interface ClientSpecInitProviderClientIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecInitProviderClientIdSelectorPolicy#resolution
   */
  readonly resolution?: ClientSpecInitProviderClientIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecInitProviderClientIdSelectorPolicy#resolve
   */
  readonly resolve?: ClientSpecInitProviderClientIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecInitProviderClientIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderClientIdSelectorPolicy(obj: ClientSpecInitProviderClientIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClientSpecInitProviderRealmIdRefPolicy
 */
export interface ClientSpecInitProviderRealmIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecInitProviderRealmIdRefPolicy#resolution
   */
  readonly resolution?: ClientSpecInitProviderRealmIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecInitProviderRealmIdRefPolicy#resolve
   */
  readonly resolve?: ClientSpecInitProviderRealmIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecInitProviderRealmIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderRealmIdRefPolicy(obj: ClientSpecInitProviderRealmIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClientSpecInitProviderRealmIdSelectorPolicy
 */
export interface ClientSpecInitProviderRealmIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecInitProviderRealmIdSelectorPolicy#resolution
   */
  readonly resolution?: ClientSpecInitProviderRealmIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecInitProviderRealmIdSelectorPolicy#resolve
   */
  readonly resolve?: ClientSpecInitProviderRealmIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecInitProviderRealmIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderRealmIdSelectorPolicy(obj: ClientSpecInitProviderRealmIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecProviderConfigRefPolicyResolution
 */
export enum ClientSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecProviderConfigRefPolicyResolve
 */
export enum ClientSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClientSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClientSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClientSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClientSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClientSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy
 */
export interface ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy#resolution
   */
  readonly resolution?: ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy#resolve
   */
  readonly resolve?: ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy(obj: ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy
 */
export interface ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy#resolution
   */
  readonly resolution?: ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy#resolve
   */
  readonly resolve?: ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy(obj: ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy
 */
export interface ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy#resolution
   */
  readonly resolution?: ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy#resolve
   */
  readonly resolve?: ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy(obj: ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy
 */
export interface ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy#resolution
   */
  readonly resolution?: ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy#resolve
   */
  readonly resolve?: ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy(obj: ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecForProviderClientIdRefPolicyResolution
 */
export enum ClientSpecForProviderClientIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecForProviderClientIdRefPolicyResolve
 */
export enum ClientSpecForProviderClientIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecForProviderClientIdSelectorPolicyResolution
 */
export enum ClientSpecForProviderClientIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecForProviderClientIdSelectorPolicyResolve
 */
export enum ClientSpecForProviderClientIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecForProviderRealmIdRefPolicyResolution
 */
export enum ClientSpecForProviderRealmIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecForProviderRealmIdRefPolicyResolve
 */
export enum ClientSpecForProviderRealmIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecForProviderRealmIdSelectorPolicyResolution
 */
export enum ClientSpecForProviderRealmIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecForProviderRealmIdSelectorPolicyResolve
 */
export enum ClientSpecForProviderRealmIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy
 */
export interface ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy#resolution
   */
  readonly resolution?: ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy#resolve
   */
  readonly resolve?: ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy(obj: ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy
 */
export interface ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy#resolution
   */
  readonly resolution?: ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy#resolve
   */
  readonly resolve?: ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy(obj: ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy
 */
export interface ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy#resolution
   */
  readonly resolution?: ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy#resolve
   */
  readonly resolve?: ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy(obj: ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy
 */
export interface ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy#resolution
   */
  readonly resolution?: ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy#resolve
   */
  readonly resolve?: ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy(obj: ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecInitProviderClientIdRefPolicyResolution
 */
export enum ClientSpecInitProviderClientIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecInitProviderClientIdRefPolicyResolve
 */
export enum ClientSpecInitProviderClientIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecInitProviderClientIdSelectorPolicyResolution
 */
export enum ClientSpecInitProviderClientIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecInitProviderClientIdSelectorPolicyResolve
 */
export enum ClientSpecInitProviderClientIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecInitProviderRealmIdRefPolicyResolution
 */
export enum ClientSpecInitProviderRealmIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecInitProviderRealmIdRefPolicyResolve
 */
export enum ClientSpecInitProviderRealmIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecInitProviderRealmIdSelectorPolicyResolution
 */
export enum ClientSpecInitProviderRealmIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecInitProviderRealmIdSelectorPolicyResolve
 */
export enum ClientSpecInitProviderRealmIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClientSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClientSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicyResolution
 */
export enum ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicyResolve
 */
export enum ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicyResolution
 */
export enum ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicyResolve
 */
export enum ClientSpecForProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicyResolution
 */
export enum ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicyResolve
 */
export enum ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicyResolution
 */
export enum ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicyResolve
 */
export enum ClientSpecForProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicyResolution
 */
export enum ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicyResolve
 */
export enum ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicyResolution
 */
export enum ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicyResolve
 */
export enum ClientSpecInitProviderAuthenticationFlowBindingOverridesBrowserIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicyResolution
 */
export enum ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicyResolve
 */
export enum ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicyResolution
 */
export enum ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicyResolve
 */
export enum ClientSpecInitProviderAuthenticationFlowBindingOverridesDirectGrantIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

